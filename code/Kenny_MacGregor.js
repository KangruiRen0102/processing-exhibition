let scale = 10; // Each cell will be 10x10 pixels
let rows, cols;
let flowfield; // Define flow field as a 2D array of cells
let swarm = [];
let swarmSize = 2500; // Number of particles

function setup() {
  createCanvas(1200, 700);
  colorMode(HSB, 360, 100, 100); // Switch from RGB to HSB
  rows = int(height / scale);
  cols = int(width / scale);
  flowfield = new Array(rows).fill(0).map(() => new Array(cols).fill(0));
  generateFlowField();
  background(0);

  // Initialize swarm
  for (let i = 0; i < swarmSize; i++) {
    swarm.push(new Particle());
  }
}

class Particle {
  constructor() {
    this.position = createVector(random(width), random(height)); // Random position
    this.velocity = createVector(0, 0); // Initially 0 velocity
  }

  update() {
    let acceleration = createVector(0, 0); // Acceleration starts at 0
    let force = 1; // Force generated by each vector
    let row = int(this.position.y / scale);
    let col = int(this.position.x / scale);

    if (row >= 0 && row < rows && col >= 0 && col < cols) {
      let angle = flowfield[row][col];
      acceleration.x = force * cos(angle); // Define particle acceleration x
      acceleration.y = force * sin(angle); // Define particle acceleration y
    }

    this.velocity.add(acceleration); // Add acceleration to velocity
    this.position.add(this.velocity); // Add velocity to position

    // Wrap around the edges of the canvas
    this.position.x = (this.position.x + width) % width;
    this.position.y = (this.position.y + height) % height;

    // Friction to prevent particles from accelerating infinitely
    this.velocity.mult(0.1);
  }

  display() {
    fill(0, 100, 100, 0.05); // Reminder: HSB mode
    stroke(0, 100, 100, 0.05);
    circle(this.position.x, this.position.y, 5);
  }
}

function draw() {
  for (let particle of swarm) {
    particle.update();
    particle.display();
  }
}

function generateFlowField() {
  let noiseScale = 0.05; // "Zoom" of the noise, something to experiment with
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      // Generate noise using p5.js noise function and map to 0 to 2*PI
      flowfield[r][c] = map(noise(r * noiseScale, c * noiseScale), 0, 1, 0, TWO_PI);
    }
  }
}
